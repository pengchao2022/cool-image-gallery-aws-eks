name: Deploy Comic Website

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: comic-website-prod
  PROJECT_NAME: comic-website
  ENVIRONMENT: prod
  NAMESPACE: comic-website
  TF_BACKEND_BUCKET: comic-website-tfstate-2024

jobs:
  terraform-infrastructure:
    name: "Terraform - Create Infrastructure"
    runs-on: ubuntu-latest
    environment: production
    outputs:
      backend_ecr_url: ${{ steps.terraform-outputs.outputs.backend_ecr_url }}
      frontend_ecr_url: ${{ steps.terraform-outputs.outputs.frontend_ecr_url }}
      rds_endpoint: ${{ steps.terraform-outputs.outputs.rds_endpoint }}
      rds_port: ${{ steps.terraform-outputs.outputs.rds_port }}
      rds_username: ${{ steps.terraform-outputs.outputs.rds_username }}
      rds_database: ${{ steps.terraform-outputs.outputs.rds_database }}

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üèó Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: ‚öôÔ∏è Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ env.TF_BACKEND_BUCKET }}" \
            -backend-config="key=terraform/state/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true" \
            -backend-config="dynamodb_table=comic-website-tfstate-lock"

      - name: ‚úÖ Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: üöÄ Terraform Plan and Apply
        run: |
          cd terraform
          terraform plan -out=tfplan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"
          terraform apply -auto-approve tfplan

      - name: üìã Get Terraform Outputs
        id: terraform-outputs
        run: |
          cd terraform
          echo "üîç Getting Terraform outputs..."
          
          terraform output -json > outputs.json
          
          BACKEND_ECR_URL=$(jq -r '.backend_repository_url.value // empty' outputs.json)
          FRONTEND_ECR_URL=$(jq -r '.frontend_repository_url.value // empty' outputs.json)
          RDS_ENDPOINT=$(jq -r '.rds_endpoint.value // empty' outputs.json)
          RDS_PORT=$(jq -r '.rds_port.value // "5432"' outputs.json)
          RDS_USERNAME=$(jq -r '.rds_username.value // "comicadmin"' outputs.json)
          RDS_DATABASE=$(jq -r '.rds_database_name.value // "comicdb"' outputs.json)
          
          echo "Backend ECR URL: $BACKEND_ECR_URL"
          echo "Frontend ECR URL: $FRONTEND_ECR_URL"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "RDS Port: $RDS_PORT"
          echo "RDS Username: $RDS_USERNAME"
          echo "RDS Database: $RDS_DATABASE"
          
          if [ -z "$BACKEND_ECR_URL" ]; then
            echo "‚ùå Backend ECR URL is empty"
            exit 1
          fi
          
          if [ -z "$FRONTEND_ECR_URL" ]; then
            echo "‚ùå Frontend ECR URL is empty"
            exit 1
          fi
          
          if [ -z "$RDS_ENDPOINT" ]; then
            echo "‚ùå RDS Endpoint is empty"
            exit 1
          fi
          
          echo "backend_ecr_url=$BACKEND_ECR_URL" >> $GITHUB_OUTPUT
          echo "frontend_ecr_url=$FRONTEND_ECR_URL" >> $GITHUB_OUTPUT
          echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
          echo "rds_port=$RDS_PORT" >> $GITHUB_OUTPUT
          echo "rds_username=$RDS_USERNAME" >> $GITHUB_OUTPUT
          echo "rds_database=$RDS_DATABASE" >> $GITHUB_OUTPUT
          echo "‚úÖ All outputs extracted successfully"

      - name: üîç Verify RDS Configuration
        run: |
          echo "üîç Verifying RDS configuration..."
          aws rds describe-db-instances \
            --region ${{ env.AWS_REGION }} \
            --query 'DBInstances[].{DBInstanceIdentifier:DBInstanceIdentifier, Status:DBInstanceStatus, Endpoint:Endpoint.Address, Port:Endpoint.Port}' \
            --output table

      - name: ‚ò∏Ô∏è Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: üß∞ Setup kubectl
        run: |
          sudo snap install kubectl --classic

  build-and-push-images:
    name: "Build and Push Docker Images"
    runs-on: ubuntu-latest
    needs: terraform-infrastructure
    environment: production
    if: needs.terraform-infrastructure.result == 'success'
    
    outputs:
      backend_image: ${{ steps.build-backend.outputs.image_tag }}
      frontend_image: ${{ steps.build-frontend.outputs.image_tag }}

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîç Get AWS Account ID and ECR Registry
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          ECR_REGISTRY="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV

      - name: üîê Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: üîç Set ECR URLs from previous job
        run: |
          echo "BACKEND_ECR_URL=${{ needs.terraform-infrastructure.outputs.backend_ecr_url }}" >> $GITHUB_ENV
          echo "FRONTEND_ECR_URL=${{ needs.terraform-infrastructure.outputs.frontend_ecr_url }}" >> $GITHUB_ENV

      - name: üèó Check if Backend Image Exists
        id: check-backend
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:8}"
          BACKEND_IMAGE="$BACKEND_ECR_URL:$IMAGE_TAG"
          if docker manifest inspect $BACKEND_IMAGE > /dev/null 2>&1; then
            echo "image_exists=true" >> $GITHUB_OUTPUT
            echo "image_tag=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
            echo "image_tag=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          fi

      - name: üß± Build Backend Image (if needed)
        id: build-backend
        if: steps.check-backend.outputs.image_exists == 'false'
        run: |
          cd backend
          IMAGE_TAG="${GITHUB_SHA:0:8}"
          BACKEND_IMAGE="$BACKEND_ECR_URL:$IMAGE_TAG"
          docker build -t $BACKEND_IMAGE .
          docker push $BACKEND_IMAGE
          echo "image_tag=$BACKEND_IMAGE" >> $GITHUB_OUTPUT

      - name: üé® Build Frontend Image
        id: build-frontend
        run: |
          cd frontend
          IMAGE_TAG="${GITHUB_SHA:0:8}"
          FRONTEND_IMAGE="$FRONTEND_ECR_URL:$IMAGE_TAG"
          docker build -t $FRONTEND_IMAGE .
          docker push $FRONTEND_IMAGE
          echo "image_tag=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT

  deploy-applications:
    name: "Deploy Applications to EKS"
    runs-on: ubuntu-latest
    needs: 
      - terraform-infrastructure
      - build-and-push-images
    environment: production
    if: needs.terraform-infrastructure.result == 'success'

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîç Set Deployment Variables
        run: |
          echo "BACKEND_IMAGE=${{ needs.build-and-push-images.outputs.backend_image }}" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=${{ needs.build-and-push-images.outputs.frontend_image }}" >> $GITHUB_ENV
          echo "RDS_ENDPOINT=${{ needs.terraform-infrastructure.outputs.rds_endpoint }}" >> $GITHUB_ENV
          echo "RDS_PORT=${{ needs.terraform-infrastructure.outputs.rds_port }}" >> $GITHUB_ENV
          echo "RDS_USERNAME=${{ needs.terraform-infrastructure.outputs.rds_username }}" >> $GITHUB_ENV
          echo "RDS_DATABASE=${{ needs.terraform-infrastructure.outputs.rds_database }}" >> $GITHUB_ENV
          
          # Ê∏ÖÁêÜ RDS Á´ØÁÇπÔºàÁßªÈô§Á´ØÂè£ÈÉ®ÂàÜÔºâ
          CLEANED_RDS_ENDPOINT=$(echo "$RDS_ENDPOINT" | cut -d':' -f1)
          echo "RDS_ENDPOINT=$CLEANED_RDS_ENDPOINT" >> $GITHUB_ENV
          
          # ËÆæÁΩÆÂâçÁ´Ø URL
          FRONTEND_URL="http://comic-website-alb-123456789.us-east-1.elb.amazonaws.com"
          echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_ENV

      - name: ‚ò∏Ô∏è Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: üß∞ Setup kubectl
        run: |
          sudo snap install kubectl --classic

      - name: üóÉ Create Namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: üöÄ Deploy Backend with Environment Variables
        run: |
          echo "üöÄ Deploying backend with environment variables..."
          
          cat <<EOF > backend-deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backend-deployment
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: backend
              app.kubernetes.io/managed-by: github-actions
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: backend
            template:
              metadata:
                labels:
                  app: backend
              spec:
                serviceAccountName: comic-backend-sa
                containers:
                - name: backend
                  image: $BACKEND_IMAGE
                  ports:
                  - containerPort: 3000
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: PORT
                    value: "3000"
                  - name: FRONTEND_URL
                    value: "$FRONTEND_URL"
                  - name: DB_HOST
                    value: "$RDS_ENDPOINT"
                  - name: DB_PORT
                    value: "$RDS_PORT"
                  - name: DB_NAME
                    value: "$RDS_DATABASE"
                  - name: DB_USER
                    value: "$RDS_USERNAME"
                  - name: DB_PASSWORD
                    value: "${{ secrets.DB_PASSWORD }}"
                  - name: JWT_SECRET
                    value: "${{ secrets.JWT_SECRET }}"
                  - name: JWT_EXPIRES_IN
                    value: "7d"
                  - name: AWS_REGION
                    value: "${{ env.AWS_REGION }}"
                  - name: AWS_ACCESS_KEY_ID
                    value: "${{ secrets.AWS_ACCESS_KEY_ID }}"
                  - name: AWS_SECRET_ACCESS_KEY
                    value: "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
                  - name: S3_BUCKET_NAME
                    value: "${{ secrets.S3_BUCKET_NAME }}"
                  - name: AWS_STS_REGIONAL_ENDPOINTS
                    value: "regional"
                  - name: AWS_ROLE_ARN
                    value: "arn:aws:iam::123456789012:role/comic-website-prod-app-backend-role"
                  - name: AWS_WEB_IDENTITY_TOKEN_FILE
                    value: "/var/run/secrets/eks.amazonaws.com/serviceaccount/token"
                  resources:
                    requests:
                      cpu: 200m
                      memory: 256Mi
                    limits:
                      cpu: 500m
                      memory: 512Mi
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 60
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 1
                  startupProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 10
                    periodSeconds: 10
                    timeoutSeconds: 1
                    failureThreshold: 30
          EOF
          
          kubectl apply -f backend-deployment.yaml
          echo "‚úÖ Backend deployment created with environment variables"

      - name: üöÄ Deploy Frontend
        run: |
          cat <<EOF > frontend-deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend-deployment
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: frontend
              app.kubernetes.io/managed-by: github-actions
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: frontend
            template:
              metadata:
                labels:
                  app: frontend
              spec:
                containers:
                - name: frontend
                  image: $FRONTEND_IMAGE
                  ports:
                  - containerPort: 80
                  resources:
                    requests:
                      cpu: 100m
                      memory: 128Mi
                    limits:
                      cpu: 200m
                      memory: 256Mi
          EOF
          
          kubectl apply -f frontend-deployment.yaml
          echo "‚úÖ Frontend deployment created"

      - name: üöÄ Deploy Services and Ingress
        run: |
          # ÂàõÂª∫ backend service
          cat <<EOF > backend-service.yaml
          apiVersion: v1
          kind: Service
          metadata:
            name: backend-service
            namespace: ${{ env.NAMESPACE }}
          spec:
            selector:
              app: backend
            ports:
            - port: 3000
              targetPort: 3000
          EOF
          
          # ÂàõÂª∫ frontend service
          cat <<EOF > frontend-service.yaml
          apiVersion: v1
          kind: Service
          metadata:
            name: frontend-service
            namespace: ${{ env.NAMESPACE }}
          spec:
            selector:
              app: frontend
            ports:
            - port: 80
              targetPort: 80
          EOF
          
          # ÂàõÂª∫ ingress
          cat <<EOF > ingress.yaml
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: comic-website-ingress
            namespace: ${{ env.NAMESPACE }}
            annotations:
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
              alb.ingress.kubernetes.io/ssl-redirect: '443'
          spec:
            ingressClassName: alb
            rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
                - path: /api
                  pathType: Prefix
                  backend:
                    service:
                      name: backend-service
                      port:
                        number: 3000
                - path: /health
                  pathType: Prefix
                  backend:
                    service:
                      name: backend-service
                      port:
                        number: 3000
          EOF
          
          kubectl apply -f backend-service.yaml
          kubectl apply -f frontend-service.yaml
          kubectl apply -f ingress.yaml
          echo "‚úÖ Services and ingress created"

      - name: ‚è≥ Wait for Deployments
        run: |
          echo "üîé Waiting for deployments to be ready..."
          timeout 300s bash -c "
            while ! kubectl rollout status deployment/backend-deployment -n ${{ env.NAMESPACE }} --timeout=60s 2>/dev/null; do
              echo '‚è≥ Backend still deploying...'
              sleep 10
            done
          " || echo "‚ö†Ô∏è Backend deployment timeout, continuing..."

          timeout 180s bash -c "
            while ! kubectl rollout status deployment/frontend-deployment -n ${{ env.NAMESPACE }} --timeout=60s 2>/dev/null; do
              echo '‚è≥ Frontend still deploying...'
              sleep 10
            done
          " || echo "‚ö†Ô∏è Frontend deployment timeout, continuing..."

      - name: üîç Verify Deployment
        run: |
          echo "üìä Deployment status:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          
          echo -e "\nüîç Backend environment variables:"
          BACKEND_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=backend -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$BACKEND_POD" ]; then
            kubectl exec $BACKEND_POD -n ${{ env.NAMESPACE }} -- env | grep -E "(DB_|NODE_ENV|PORT)" || echo "Cannot check env vars"
          fi
          
          echo -e "\nüìã Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}
          
          echo -e "\nüåê Ingress:"
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: üîç Check Application Logs
        run: |
          echo "üîç Checking backend logs..."
          BACKEND_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=backend -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$BACKEND_POD" ]; then
            kubectl logs $BACKEND_POD -n ${{ env.NAMESPACE }} --tail=50 || true
          else
            echo "‚ùå No backend pod found"
          fi

      - name: üåê Get ALB URL
        run: |
          echo "üöÄ Retrieving ALB URL..."
          for i in {1..5}; do
            ALB_URL=$(kubectl get ingress comic-website-ingress -n ${{ env.NAMESPACE }} -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$ALB_URL" ]; then
              echo "‚úÖ ALB is ready: http://$ALB_URL"
              echo "ALB_URL=http://$ALB_URL" >> $GITHUB_ENV
              break
            fi
            echo "‚è≥ ALB not ready yet (attempt $i/5)..."
            sleep 10
          done