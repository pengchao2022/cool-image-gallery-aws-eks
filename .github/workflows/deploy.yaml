name: Deploy Comic Website

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: comic-website-prod
  PROJECT_NAME: comic-website
  ENVIRONMENT: prod
  NAMESPACE: comic-website
  TF_BACKEND_BUCKET: comic-website-tfstate-2024

jobs:
  terraform-infrastructure:
    name: "Terraform - Create Infrastructure"
    runs-on: ubuntu-latest
    environment: production
    outputs:
      backend_ecr_url: ${{ steps.terraform-outputs.outputs.backend_ecr_url }}
      frontend_ecr_url: ${{ steps.terraform-outputs.outputs.frontend_ecr_url }}
      rds_endpoint: ${{ steps.terraform-outputs.outputs.rds_endpoint }}
      rds_port: ${{ steps.terraform-outputs.outputs.rds_port }}
      rds_username: ${{ steps.terraform-outputs.outputs.rds_username }}
      rds_database: ${{ steps.terraform-infrastructure.outputs.rds_database }}
      rds_password: ${{ steps.terraform-outputs.outputs.rds_password }}

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üèó Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: ‚öôÔ∏è Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ env.TF_BACKEND_BUCKET }}" \
            -backend-config="key=terraform/state/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true" \
            -backend-config="dynamodb_table=comic-website-tfstate-lock"

      - name: ‚úÖ Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: üöÄ Terraform Plan and Apply
        run: |
          cd terraform
          terraform plan -out=tfplan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"
          terraform apply -auto-approve tfplan

      - name: üìã Get Terraform Outputs
        id: terraform-outputs
        run: |
          cd terraform
          echo "üîç Getting Terraform outputs..."
          
          # ‰ΩøÁî® JSON ÊñπÂºèÂÆâÂÖ®Ëé∑ÂèñÊâÄÊúâËæìÂá∫
          terraform output -json > outputs.json
          
          # ECR URLs
          BACKEND_ECR_URL=$(jq -r '.backend_repository_url.value // empty' outputs.json)
          FRONTEND_ECR_URL=$(jq -r '.frontend_repository_url.value // empty' outputs.json)
          
          # RDS ‰ø°ÊÅØ - ‰ΩøÁî®Ê≠£Á°ÆÁöÑËæìÂá∫ÈîÆÂêç
          RDS_ENDPOINT=$(jq -r '.rds_endpoint.value // empty' outputs.json)
          RDS_PORT=$(jq -r '.rds_port.value // "5432"' outputs.json)
          RDS_USERNAME=$(jq -r '.rds_username.value // "comicadmin"' outputs.json)
          RDS_DATABASE=$(jq -r '.rds_database_name.value // "comicdb"' outputs.json)
          RDS_PASSWORD=$(jq -r '.rds_password.value // empty' outputs.json)
          
          echo "Backend ECR URL: $BACKEND_ECR_URL"
          echo "Frontend ECR URL: $FRONTEND_ECR_URL"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "RDS Port: $RDS_PORT"
          echo "RDS Username: ***"
          echo "RDS Database: $RDS_DATABASE"
          echo "RDS Password: *** (length: ${#RDS_PASSWORD})"
          
          # È™åËØÅÂÖ≥ÈîÆËæìÂá∫
          if [ -z "$BACKEND_ECR_URL" ]; then
            echo "‚ùå Backend ECR URL is empty"
            exit 1
          fi
          
          if [ -z "$FRONTEND_ECR_URL" ]; then
            echo "‚ùå Frontend ECR URL is empty"
            exit 1
          fi
          
          if [ -z "$RDS_ENDPOINT" ]; then
            echo "‚ùå RDS Endpoint is empty"
            exit 1
          fi

          if [ -z "$RDS_PASSWORD" ]; then
            echo "‚ùå RDS Password is empty - this will cause database connection failures"
            exit 1
          fi
          
          echo "backend_ecr_url=$BACKEND_ECR_URL" >> $GITHUB_OUTPUT
          echo "frontend_ecr_url=$FRONTEND_ECR_URL" >> $GITHUB_OUTPUT
          echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
          echo "rds_port=$RDS_PORT" >> $GITHUB_OUTPUT
          echo "rds_username=$RDS_USERNAME" >> $GITHUB_OUTPUT
          echo "rds_database=$RDS_DATABASE" >> $GITHUB_OUTPUT
          echo "rds_password=$RDS_PASSWORD" >> $GITHUB_OUTPUT
          echo "‚úÖ All outputs extracted successfully"

      - name: üîç Verify RDS Configuration
        run: |
          echo "üîç Verifying RDS configuration..."
          
          # Ëé∑Âèñ RDS ËØ¶ÁªÜ‰ø°ÊÅØ
          echo "=== RDS Instance Details ==="
          aws rds describe-db-instances \
            --region ${{ env.AWS_REGION }} \
            --query 'DBInstances[].{DBInstanceIdentifier:DBInstanceIdentifier, Status:DBInstanceStatus, Endpoint:Endpoint.Address, Port:Endpoint.Port}' \
            --output table
          
          echo "‚úÖ RDS instance is properly configured"

      - name: ‚ò∏Ô∏è Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: üß∞ Setup kubectl
        run: |
          sudo snap install kubectl --classic

      - name: üß† Install or Upgrade ALB Ingress Controller
        run: |
          set -e
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update

          VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION --query "cluster.resourcesVpcConfig.vpcId" --output text)
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          cat <<EOF > alb-serviceaccount.yaml
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: aws-load-balancer-controller
            namespace: kube-system
            annotations:
              eks.amazonaws.com/role-arn: arn:aws:iam::$ACCOUNT_ID:role/AmazonEKSLoadBalancerControllerRole-$CLUSTER_NAME
          EOF

          kubectl apply -f alb-serviceaccount.yaml

          cat <<EOF > alb-values.yaml
          clusterName: $CLUSTER_NAME
          region: $AWS_REGION
          vpcId: $VPC_ID
          serviceAccount:
            create: false
            name: aws-load-balancer-controller
          EOF

          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            -f alb-values.yaml \
            --version 1.6.1 \
            --wait

  build-and-push-images:
    name: "Build and Push Docker Images"
    runs-on: ubuntu-latest
    needs: terraform-infrastructure
    environment: production
    if: needs.terraform-infrastructure.result == 'success'
    
    outputs:
      backend_image: ${{ steps.build-backend.outputs.image_tag }}
      frontend_image: ${{ steps.build-frontend.outputs.image_tag }}

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîç Get AWS Account ID and ECR Registry
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          ECR_REGISTRY="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          echo "‚úÖ AWS Account ID: $ACCOUNT_ID"
          echo "‚úÖ ECR Registry: $ECR_REGISTRY"

      - name: üîê Login to ECR
        run: |
          echo "Logging into ECR registry: $ECR_REGISTRY"
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: üîç Set ECR URLs from previous job
        run: |
          echo "BACKEND_ECR_URL=${{ needs.terraform-infrastructure.outputs.backend_ecr_url }}" >> $GITHUB_ENV
          echo "FRONTEND_ECR_URL=${{ needs.terraform-infrastructure.outputs.frontend_ecr_url }}" >> $GITHUB_ENV
          echo "‚úÖ Backend ECR URL: ${{ needs.terraform-infrastructure.outputs.backend_ecr_url }}"
          echo "‚úÖ Frontend ECR URL: ${{ needs.terraform-infrastructure.outputs.frontend_ecr_url }}"

      - name: üèó Check if Backend Image Exists
        id: check-backend
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:8}"
          BACKEND_IMAGE="$BACKEND_ECR_URL:$IMAGE_TAG"
          echo "Checking if backend image exists: $BACKEND_IMAGE"
          
          # ‰ΩøÁî® docker manifest inspect Ê£ÄÊü•ÈïúÂÉèÊòØÂê¶Â≠òÂú®
          if docker manifest inspect $BACKEND_IMAGE > /dev/null 2>&1; then
            echo "‚úÖ Backend image already exists, skipping build"
            echo "image_exists=true" >> $GITHUB_OUTPUT
            echo "image_tag=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          else
            echo "üöÄ Backend image does not exist, will build"
            echo "image_exists=false" >> $GITHUB_OUTPUT
            echo "image_tag=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          fi

      - name: üß± Build Backend Image (if needed)
        id: build-backend
        if: steps.check-backend.outputs.image_exists == 'false'
        run: |
          cd backend
          IMAGE_TAG="${GITHUB_SHA:0:8}"
          BACKEND_IMAGE="$BACKEND_ECR_URL:$IMAGE_TAG"
          
          echo "üèó Building backend image..."
          docker build -t $BACKEND_IMAGE .
          
          echo "üöÄ Pushing backend image..."
          docker push $BACKEND_IMAGE
          
          echo "‚úÖ Backend image pushed: $BACKEND_IMAGE"
          echo "image_tag=$BACKEND_IMAGE" >> $GITHUB_OUTPUT

      - name: üé® Build Frontend Image
        id: build-frontend
        run: |
          cd frontend
          IMAGE_TAG="${GITHUB_SHA:0:8}"
          FRONTEND_IMAGE="$FRONTEND_ECR_URL:$IMAGE_TAG"
          
          echo "üèó Building frontend image..."
          docker build -t $FRONTEND_IMAGE .
          
          echo "üöÄ Pushing frontend image..."
          docker push $FRONTEND_IMAGE
          
          echo "‚úÖ Frontend image pushed: $FRONTEND_IMAGE"
          echo "image_tag=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT

      - name: üîç Verify Built Images
        run: |
          echo "üîç Verifying built images..."
          echo "Backend Image: ${{ steps.build-backend.outputs.image_tag || steps.check-backend.outputs.image_tag }}"
          echo "Frontend Image: ${{ steps.build-frontend.outputs.image_tag }}"
          
          # È™åËØÅÂêéÁ´ØÈïúÂÉèÂÜÖÂÆπ
          BACKEND_IMAGE="${{ steps.build-backend.outputs.image_tag || steps.check-backend.outputs.image_tag }}"
          if [ -n "$BACKEND_IMAGE" ]; then
            echo "=== Backend Image Package.json ==="
            docker run --rm $BACKEND_IMAGE cat /app/package.json | grep '"start"' || echo "Cannot read package.json"
          fi

  deploy-applications:
    name: "Deploy Applications to EKS"
    runs-on: ubuntu-latest
    needs: 
      - terraform-infrastructure
      - build-and-push-images
    environment: production
    if: needs.terraform-infrastructure.result == 'success'

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîç Set Environment Variables
        run: |
          echo "BACKEND_IMAGE=${{ needs.build-and-push-images.outputs.backend_image }}" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=${{ needs.build-and-push-images.outputs.frontend_image }}" >> $GITHUB_ENV
          echo "RDS_ENDPOINT=${{ needs.terraform-infrastructure.outputs.rds_endpoint }}" >> $GITHUB_ENV
          echo "RDS_PORT=${{ needs.terraform-infrastructure.outputs.rds_port }}" >> $GITHUB_ENV
          echo "RDS_USERNAME=${{ needs.terraform-infrastructure.outputs.rds_username }}" >> $GITHUB_ENV
          echo "RDS_DATABASE=${{ needs.terraform-infrastructure.outputs.rds_database }}" >> $GITHUB_ENV
          echo "RDS_PASSWORD=${{ needs.terraform-infrastructure.outputs.rds_password }}" >> $GITHUB_ENV
          
          echo "‚úÖ Backend Image: ${{ needs.build-and-push-images.outputs.backend_image }}"
          echo "‚úÖ Frontend Image: ${{ needs.build-and-push-images.outputs.frontend_image }}"
          echo "‚úÖ RDS Endpoint: ${{ needs.terraform-infrastructure.outputs.rds_endpoint }}"
          echo "‚úÖ RDS Password: *** (length: ${#RDS_PASSWORD})"

      - name: üîç Clean RDS Endpoint
        run: |
          echo "üîç Cleaning RDS endpoint..."
          CLEANED_RDS_ENDPOINT=$(echo "$RDS_ENDPOINT" | cut -d':' -f1)
          echo "Original RDS Endpoint: $RDS_ENDPOINT"
          echo "Cleaned RDS Endpoint: $CLEANED_RDS_ENDPOINT"
          echo "RDS_ENDPOINT=$CLEANED_RDS_ENDPOINT" >> $GITHUB_ENV

      - name: ‚ò∏Ô∏è Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: üß∞ Setup kubectl
        run: |
          sudo snap install kubectl --classic

      - name: üóÉ Skip External DB Test - RDS is VPC Internal
        run: |
          echo "üîç RDS Connectivity Information:"
          echo "================================================"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "RDS Port: $RDS_PORT"
          echo "RDS Database: $RDS_DATABASE"
          echo "RDS Username: $RDS_USERNAME"
          echo "RDS Password: *** (set from Terraform output)"
          echo ""
          echo "‚ö†Ô∏è  IMPORTANT: RDS Security Configuration"
          echo "================================================"
          echo "‚úÖ RDS instance status: available"
          echo "‚úÖ Security group allows: 10.0.0.0/16 (VPC internal)"
          echo "‚ùå GitHub Actions cannot connect from outside VPC"
          echo ""
          echo "üéØ Deployment Strategy:"
          echo "================================================"
          echo "1. Skipping external database connectivity test"
          echo "2. Application pods in EKS will connect from within VPC"
          echo "3. Database connections will be handled internally"
          echo "4. Continuing deployment..."
          echo ""
          echo "‚úÖ RDS is properly configured for EKS access"

      - name: üîë Apply Kubernetes Secrets with Real RDS Info
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

          kubectl delete secret rds-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true

          cat <<EOF > rds-secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: rds-secret
            namespace: ${{ env.NAMESPACE }}
          type: Opaque
          stringData:
            host: $RDS_ENDPOINT
            port: '$RDS_PORT'
            username: $RDS_USERNAME
            database: $RDS_DATABASE
            password: '$RDS_PASSWORD'
          EOF

          echo "üîç RDS Secret content:"
          echo "Host: $RDS_ENDPOINT"
          echo "Port: $RDS_PORT"
          echo "Username: $RDS_USERNAME"
          echo "Database: $RDS_DATABASE"
          echo "Password: *** (from Terraform output)"

          kubectl apply -f rds-secret.yaml
          rm rds-secret.yaml
          
          echo "‚úÖ RDS Secret applied with real connection info"

      - name: üîç Verify RDS Secret
        run: |
          echo "üîç Verifying RDS secret was created correctly..."
          sleep 5
          
          # Ê£ÄÊü• secret ÊòØÂê¶Â≠òÂú®
          kubectl get secret rds-secret -n ${{ env.NAMESPACE }} -o yaml
          
          # È™åËØÅÂØÜÁ†ÅÂ≠óÊÆµÔºà‰∏çÊòæÁ§∫ÂÆûÈôÖÂØÜÁ†ÅÔºâ
          PASSWORD_SET=$(kubectl get secret rds-secret -n ${{ env.NAMESPACE }} -o jsonpath='{.data.password}' | base64 -d)
          if [ -n "$PASSWORD_SET" ]; then
            echo "‚úÖ RDS password is set (length: ${#PASSWORD_SET} characters)"
          else
            echo "‚ùå RDS password is empty!"
            exit 1
          fi

      - name: üöÄ Deploy using Kustomize
        run: |
          echo "üöÄ Applying all manifests using Kustomize..."
          cd k8s
          kubectl apply -k . --namespace ${{ env.NAMESPACE }}

          echo "üîß Patching deployments with new image versions..."
          kubectl set image deployment/backend-deployment backend=$BACKEND_IMAGE -n ${{ env.NAMESPACE }} || true
          kubectl set image deployment/frontend-deployment frontend=$FRONTEND_IMAGE -n ${{ env.NAMESPACE }} || true

      - name: üîç Check Backend Logs for Database Connection
        run: |
          echo "üîç Checking backend pod status and database connection from within EKS..."
          sleep 60
          
          BACKEND_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=backend --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
          
          if [ -n "$BACKEND_POD" ]; then
            echo "Backend Pod: $BACKEND_POD"
            echo "=== Pod Status ==="
            kubectl get pod $BACKEND_POD -n ${{ env.NAMESPACE }} -o wide
            
            echo "=== Testing Database Connection from Within EKS Pod ==="
            kubectl exec $BACKEND_POD -n ${{ env.NAMESPACE }} -- sh -c "
              echo 'Testing database connection from within EKS cluster...'
              if command -v pg_isready >/dev/null 2>&1; then
                echo 'Using pg_isready to test connection...'
                pg_isready -h $RDS_ENDPOINT -p $RDS_PORT -t 15
                if [ \$? -eq 0 ]; then
                  echo '‚úÖ SUCCESS: Database connection successful from EKS pod'
                else
                  echo '‚ùå FAILED: Database connection failed from EKS pod'
                fi
              else
                echo '‚ÑπÔ∏è pg_isready not available in pod, checking application connectivity...'
                if timeout 10 bash -c '</dev/tcp/$RDS_ENDPOINT/$RDS_PORT'; then
                  echo '‚úÖ SUCCESS: Network connection to database successful'
                else
                  echo '‚ùå FAILED: Network connection to database failed'
                fi
              fi
            " || echo "‚ö†Ô∏è Could not execute command in pod"
            
            echo "=== Application Logs ==="
            kubectl logs $BACKEND_POD -n ${{ env.NAMESPACE }} --tail=100 || true
            
          else
            echo "‚ùå No backend pod found"
          fi

      - name: ‚è≥ Wait for Deployments (with timeout)
        run: |
          echo "üîé Waiting for deployments to be ready..."
          
          timeout 300s bash -c "
            while true; do
              if kubectl rollout status deployment/backend-deployment -n ${{ env.NAMESPACE }} --timeout=60s 2>/dev/null; then
                echo '‚úÖ Backend deployment ready'
                break
              fi
              echo '‚è≥ Backend still deploying...'
              sleep 10
            done
          " || echo "‚ö†Ô∏è Backend deployment timeout, continuing..."

          timeout 180s bash -c "
            while true; do
              if kubectl rollout status deployment/frontend-deployment -n ${{ env.NAMESPACE }} --timeout=60s 2>/dev/null; then
                echo '‚úÖ Frontend deployment ready'
                break
              fi
              echo '‚è≥ Frontend still deploying...'
              sleep 10
            done
          " || echo "‚ö†Ô∏è Frontend deployment timeout, continuing..."

      - name: üìä Quick Status Check
        run: |
          echo "üìä Current deployment status:"
          kubectl get pods -n ${{ env.NAMESPACE }} --no-headers | while read line; do
            POD_NAME=$(echo $line | awk '{print $1}')
            STATUS=$(echo $line | awk '{print $3}')
            READY=$(echo $line | awk '{print $2}')
            echo "  $POD_NAME: $STATUS ($READY)"
          done

          echo -e "\nüìã Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}

          echo -e "\nüåê Ingress:"
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: üîç Get ALB Ingress URL (Fast)
        run: |
          echo "üöÄ Retrieving ALB ingress URL..."
          
          for i in {1..3}; do
            ALB_URL=$(kubectl get ingress comic-website-ingress -n ${{ env.NAMESPACE }} -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$ALB_URL" ]; then
              echo "‚úÖ ALB is ready!"
              echo "üåê ALB URL: http://$ALB_URL"
              echo "ALB_URL=http://$ALB_URL" >> $GITHUB_ENV
              break
            fi
            echo "‚è≥ ALB not ready yet (attempt $i/3)..."
            sleep 10
          done

          if [ -z "$ALB_URL" ]; then
            echo "‚ÑπÔ∏è ALB not ready yet. It will be available soon."
            echo "You can check later with: kubectl get ingress -n ${{ env.NAMESPACE }}"
          fi

      - name: üß™ Quick Health Check
        if: env.ALB_URL != ''
        run: |
          echo "üß™ Performing quick health check..."
          timeout 30s bash -c "
            until curl -f $ALB_URL/health 2>/dev/null; do
              echo '‚è≥ Health check not ready...'
              sleep 5
            done
          " && echo "‚úÖ Health check passed!" || echo "‚ö†Ô∏è Health check timeout or failed"