name: Deploy Comic Website

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: comic-website-prod
  PROJECT_NAME: comic-website
  ENVIRONMENT: prod
  NAMESPACE: comic-website
  TF_BACKEND_BUCKET: comic-website-tfstate-2024

jobs:
  terraform-infrastructure:
    name: "Terraform - Create Infrastructure"
    runs-on: ubuntu-latest
    environment: production
    outputs:
      backend_ecr_url: ${{ steps.terraform-outputs.outputs.backend_ecr_url }}
      frontend_ecr_url: ${{ steps.terraform-outputs.outputs.frontend_ecr_url }}
      rds_endpoint: ${{ steps.terraform-outputs.outputs.rds_endpoint }}
      rds_port: ${{ steps.terraform-outputs.outputs.rds_port }}
      rds_username: ${{ steps.terraform-outputs.outputs.rds_username }}
      rds_database: ${{ steps.terraform-outputs.outputs.rds_database }}
      rds_password: ${{ steps.terraform-outputs.outputs.rds_password }}

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üèó Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: ‚öôÔ∏è Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ env.TF_BACKEND_BUCKET }}" \
            -backend-config="key=terraform/state/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true" \
            -backend-config="dynamodb_table=comic-website-tfstate-lock"

      - name: ‚úÖ Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: üöÄ Terraform Plan and Apply
        run: |
          cd terraform
          terraform plan -out=tfplan \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}"
          terraform apply -auto-approve tfplan

      - name: üìã Get Terraform Outputs
        id: terraform-outputs
        run: |
          cd terraform
          echo "üîç Getting Terraform outputs..."
          
          # ‰ΩøÁî® JSON ÊñπÂºèÂÆâÂÖ®Ëé∑ÂèñÊâÄÊúâËæìÂá∫
          terraform output -json > outputs.json
          
          # ECR URLs
          BACKEND_ECR_URL=$(jq -r '.backend_repository_url.value // empty' outputs.json)
          FRONTEND_ECR_URL=$(jq -r '.frontend_repository_url.value // empty' outputs.json)
          
          # RDS ‰ø°ÊÅØ - ‰ΩøÁî®Ê≠£Á°ÆÁöÑËæìÂá∫ÈîÆÂêç
          RDS_ENDPOINT=$(jq -r '.rds_endpoint.value // empty' outputs.json)
          RDS_PORT=$(jq -r '.rds_port.value // "5432"' outputs.json)
          RDS_USERNAME=$(jq -r '.rds_username.value // "comicadmin"' outputs.json)
          RDS_DATABASE=$(jq -r '.rds_database_name.value // "comicdb"' outputs.json)
          RDS_PASSWORD=$(jq -r '.rds_password.value // empty' outputs.json)
          
          echo "Backend ECR URL: $BACKEND_ECR_URL"
          echo "Frontend ECR URL: $FRONTEND_ECR_URL"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "RDS Port: $RDS_PORT"
          echo "RDS Username: ***"
          echo "RDS Database: $RDS_DATABASE"
          echo "RDS Password: ***"
          
          # È™åËØÅÂÖ≥ÈîÆËæìÂá∫
          if [ -z "$BACKEND_ECR_URL" ]; then
            echo "‚ùå Backend ECR URL is empty"
            exit 1
          fi
          
          if [ -z "$FRONTEND_ECR_URL" ]; then
            echo "‚ùå Frontend ECR URL is empty"
            exit 1
          fi
          
          if [ -z "$RDS_ENDPOINT" ]; then
            echo "‚ùå RDS Endpoint is empty"
            exit 1
          fi
          
          echo "backend_ecr_url=$BACKEND_ECR_URL" >> $GITHUB_OUTPUT
          echo "frontend_ecr_url=$FRONTEND_ECR_URL" >> $GITHUB_OUTPUT
          echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
          echo "rds_port=$RDS_PORT" >> $GITHUB_OUTPUT
          echo "rds_username=$RDS_USERNAME" >> $GITHUB_OUTPUT
          echo "rds_database=$RDS_DATABASE" >> $GITHUB_OUTPUT
          echo "rds_password=$RDS_PASSWORD" >> $GITHUB_OUTPUT
          echo "‚úÖ All outputs extracted successfully"

      - name: üîç Verify RDS Configuration
        run: |
          echo "üîç Verifying RDS configuration..."
          
          # Ëé∑Âèñ RDS ËØ¶ÁªÜ‰ø°ÊÅØ
          echo "=== RDS Instance Details ==="
          aws rds describe-db-instances \
            --region ${{ env.AWS_REGION }} \
            --query 'DBInstances[].{DBInstanceIdentifier:DBInstanceIdentifier, Status:DBInstanceStatus, Endpoint:Endpoint.Address, Port:Endpoint.Port}' \
            --output table
          
          echo "‚úÖ RDS instance is properly configured"

      - name: ‚ò∏Ô∏è Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: üß∞ Setup kubectl
        run: |
          sudo snap install kubectl --classic

      - name: üß† Install or Upgrade ALB Ingress Controller
        run: |
          set -e
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update

          VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION --query "cluster.resourcesVpcConfig.vpcId" --output text)
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          cat <<EOF > alb-serviceaccount.yaml
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: aws-load-balancer-controller
            namespace: kube-system
            annotations:
              eks.amazonaws.com/role-arn: arn:aws:iam::$ACCOUNT_ID:role/AmazonEKSLoadBalancerControllerRole-$CLUSTER_NAME
          EOF

          kubectl apply -f alb-serviceaccount.yaml

          cat <<EOF > alb-values.yaml
          clusterName: $CLUSTER_NAME
          region: $AWS_REGION
          vpcId: $VPC_ID
          serviceAccount:
            create: false
            name: aws-load-balancer-controller
          EOF

          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            -f alb-values.yaml \
            --version 1.6.1 \
            --wait

  deploy-applications:
    name: "Deploy Applications to EKS"
    runs-on: ubuntu-latest
    needs: terraform-infrastructure
    environment: production
    if: needs.terraform-infrastructure.result == 'success'

    steps:
      - name: üß© Checkout code
        uses: actions/checkout@v4

      - name: üîë Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîç Set Environment Variables from previous job
        run: |
          echo "BACKEND_ECR_URL=${{ needs.terraform-infrastructure.outputs.backend_ecr_url }}" >> $GITHUB_ENV
          echo "FRONTEND_ECR_URL=${{ needs.terraform-infrastructure.outputs.frontend_ecr_url }}" >> $GITHUB_ENV
          echo "RDS_ENDPOINT=${{ needs.terraform-infrastructure.outputs.rds_endpoint }}" >> $GITHUB_ENV
          echo "RDS_PORT=${{ needs.terraform-infrastructure.outputs.rds_port }}" >> $GITHUB_ENV
          echo "RDS_USERNAME=${{ needs.terraform-infrastructure.outputs.rds_username }}" >> $GITHUB_ENV
          echo "RDS_DATABASE=${{ needs.terraform-infrastructure.outputs.rds_database }}" >> $GITHUB_ENV
          echo "RDS_PASSWORD=${{ needs.terraform-infrastructure.outputs.rds_password }}" >> $GITHUB_ENV
          
          echo "‚úÖ Backend ECR URL: ${{ needs.terraform-infrastructure.outputs.backend_ecr_url }}"
          echo "‚úÖ Frontend ECR URL: ${{ needs.terraform-infrastructure.outputs.frontend_ecr_url }}"
          echo "‚úÖ RDS Endpoint: ${{ needs.terraform-infrastructure.outputs.rds_endpoint }}"
          echo "‚úÖ RDS Port: ${{ needs.terraform-infrastructure.outputs.rds_port }}"
          echo "‚úÖ RDS Username: ${{ needs.terraform-infrastructure.outputs.rds_username }}"
          echo "‚úÖ RDS Database: ${{ needs.terraform-infrastructure.outputs.rds_database }}"
          echo "‚úÖ RDS Password: ***"

      - name: üîç Clean RDS Endpoint
        run: |
          echo "üîç Cleaning RDS endpoint..."
          # ÁßªÈô§Á´ØÁÇπ‰∏≠ÂèØËÉΩÂåÖÂê´ÁöÑÁ´ØÂè£Âè∑
          CLEANED_RDS_ENDPOINT=$(echo "$RDS_ENDPOINT" | cut -d':' -f1)
          echo "Original RDS Endpoint: $RDS_ENDPOINT"
          echo "Cleaned RDS Endpoint: $CLEANED_RDS_ENDPOINT"
          echo "RDS_PORT=$RDS_PORT"
          
          # Êõ¥Êñ∞ÁéØÂ¢ÉÂèòÈáè
          echo "RDS_ENDPOINT=$CLEANED_RDS_ENDPOINT" >> $GITHUB_ENV

      - name: ‚ò∏Ô∏è Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: üß∞ Setup kubectl
        run: |
          sudo snap install kubectl --classic

      - name: üîç Get AWS Account ID and ECR Registry
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          ECR_REGISTRY="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          echo "‚úÖ AWS Account ID: $ACCOUNT_ID"
          echo "‚úÖ ECR Registry: $ECR_REGISTRY"

      - name: üîê Login to ECR
        run: |
          echo "Logging into ECR registry: $ECR_REGISTRY"
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: üîç Debug Environment Variables
        run: |
          echo "Backend ECR URL: $BACKEND_ECR_URL"
          echo "Frontend ECR URL: $FRONTEND_ECR_URL"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "RDS Port: $RDS_PORT"
          echo "RDS Username: $RDS_USERNAME"
          echo "RDS Database: $RDS_DATABASE"
          echo "RDS Password: ***"
          echo "GITHUB_SHA: $GITHUB_SHA"
          echo "GITHUB_SHA shortened: ${GITHUB_SHA:0:8}"

      - name: üóÉ Skip External DB Test - RDS is VPC Internal
        run: |
          echo "üîç RDS Connectivity Information:"
          echo "================================================"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "RDS Port: $RDS_PORT"
          echo "RDS Database: $RDS_DATABASE"
          echo "RDS Username: $RDS_USERNAME"
          echo ""
          echo "‚ö†Ô∏è  IMPORTANT: RDS Security Configuration"
          echo "================================================"
          echo "‚úÖ RDS instance status: available"
          echo "‚úÖ Security group allows: 10.0.0.0/16 (VPC internal)"
          echo "‚ùå GitHub Actions cannot connect from outside VPC"
          echo ""
          echo "üéØ Deployment Strategy:"
          echo "================================================"
          echo "1. Skipping external database connectivity test"
          echo "2. Application pods in EKS will connect from within VPC"
          echo "3. Database connections will be handled internally"
          echo "4. Continuing deployment..."
          echo ""
          echo "‚úÖ RDS is properly configured for EKS access"

      - name: üß± Build and Push Backend Image
        run: |
          cd backend
          echo "üèó Building backend image..."
          docker build -t $BACKEND_ECR_URL:${GITHUB_SHA:0:8} .
          echo "üöÄ Pushing backend image to: $BACKEND_ECR_URL:${GITHUB_SHA:0:8}"
          docker push $BACKEND_ECR_URL:${GITHUB_SHA:0:8}
          echo "‚úÖ Backend image pushed: $BACKEND_ECR_URL:${GITHUB_SHA:0:8}"

      - name: üé® Build and Push Frontend Image
        run: |
          cd frontend
          echo "üèó Building frontend image..."
          docker build -t $FRONTEND_ECR_URL:${GITHUB_SHA:0:8} .
          echo "üöÄ Pushing frontend image to: $FRONTEND_ECR_URL:${GITHUB_SHA:0:8}"
          docker push $FRONTEND_ECR_URL:${GITHUB_SHA:0:8}
          echo "‚úÖ Frontend image pushed: $FRONTEND_ECR_URL:${GITHUB_SHA:0:8}"

      - name: üîë Apply Kubernetes Secrets with Real RDS Info
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

          # Âà†Èô§ÊóßÁöÑ secretÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
          kubectl delete secret rds-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true

          cat <<EOF > rds-secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: rds-secret
            namespace: ${{ env.NAMESPACE }}
          type: Opaque
          stringData:
            host: $RDS_ENDPOINT
            port: '$RDS_PORT'
            username: $RDS_USERNAME
            database: $RDS_DATABASE
            password: $RDS_PASSWORD
          EOF

          echo "üîç RDS Secret content:"
          echo "Host: $RDS_ENDPOINT"
          echo "Port: $RDS_PORT"
          echo "Username: $RDS_USERNAME"
          echo "Database: $RDS_DATABASE"
          echo "Password: ***"

          kubectl apply -f rds-secret.yaml
          rm rds-secret.yaml
          
          echo "‚úÖ RDS Secret applied with real connection info"

      - name: üöÄ Deploy using Kustomize
        run: |
          echo "üöÄ Applying all manifests using Kustomize..."
          cd k8s
          kubectl apply -k . --namespace ${{ env.NAMESPACE }}

          echo "üîß Patching deployments with new image versions..."
          BACKEND_IMAGE=$BACKEND_ECR_URL:${GITHUB_SHA:0:8}
          FRONTEND_IMAGE=$FRONTEND_ECR_URL:${GITHUB_SHA:0:8}

          kubectl set image deployment/backend-deployment backend=$BACKEND_IMAGE -n ${{ env.NAMESPACE }} || true
          kubectl set image deployment/frontend-deployment frontend=$FRONTEND_IMAGE -n ${{ env.NAMESPACE }} || true

      - name: üîç Check Backend Logs for Database Connection
        run: |
          echo "üîç Checking backend pod status and database connection from within EKS..."
          # Á≠âÂæÖ‰∏Ä‰∏ãËÆ© pod ÂêØÂä®
          sleep 60
          
          # Ëé∑ÂèñÊúÄÊñ∞ÁöÑ backend pod
          BACKEND_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=backend --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
          
          if [ -n "$BACKEND_POD" ]; then
            echo "Backend Pod: $BACKEND_POD"
            echo "=== Pod Status ==="
            kubectl get pod $BACKEND_POD -n ${{ env.NAMESPACE }} -o wide
            
            echo "=== Testing Database Connection from Within EKS Pod ==="
            # Âú® pod ÂÜÖÈÉ®ÊµãËØïÊï∞ÊçÆÂ∫ìËøûÊé•Ôºà‰ªé EKS ÂÜÖÈÉ®Ôºâ
            kubectl exec $BACKEND_POD -n ${{ env.NAMESPACE }} -- sh -c "
              echo 'Testing database connection from within EKS cluster...'
              if command -v pg_isready >/dev/null 2>&1; then
                echo 'Using pg_isready to test connection...'
                pg_isready -h $RDS_ENDPOINT -p $RDS_PORT -t 15
                if [ \$? -eq 0 ]; then
                  echo '‚úÖ SUCCESS: Database connection successful from EKS pod'
                else
                  echo '‚ùå FAILED: Database connection failed from EKS pod'
                fi
              else
                echo '‚ÑπÔ∏è pg_isready not available in pod, checking application connectivity...'
                # Â∞ùËØïÂü∫Êú¨ÁöÑÁΩëÁªúËøûÊé•
                if timeout 10 bash -c '</dev/tcp/$RDS_ENDPOINT/$RDS_PORT'; then
                  echo '‚úÖ SUCCESS: Network connection to database successful'
                else
                  echo '‚ùå FAILED: Network connection to database failed'
                fi
              fi
            " || echo "‚ö†Ô∏è Could not execute command in pod"
            
            echo "=== Application Logs ==="
            kubectl logs $BACKEND_POD -n ${{ env.NAMESPACE }} --tail=100 || true
            
          else
            echo "‚ùå No backend pod found"
          fi

      - name: ‚è≥ Wait for Deployments (with timeout)
        run: |
          echo "üîé Waiting for deployments to be ready..."
          
          # Á≠âÂæÖÂêéÁ´ØÈÉ®ÁΩ≤ÔºàÂ∏¶Ë∂ÖÊó∂Ôºâ
          timeout 300s bash -c "
            while true; do
              if kubectl rollout status deployment/backend-deployment -n ${{ env.NAMESPACE }} --timeout=60s 2>/dev/null; then
                echo '‚úÖ Backend deployment ready'
                break
              fi
              echo '‚è≥ Backend still deploying...'
              sleep 10
            done
          " || echo "‚ö†Ô∏è Backend deployment timeout, continuing..."

          # Á≠âÂæÖÂâçÁ´ØÈÉ®ÁΩ≤ÔºàÂ∏¶Ë∂ÖÊó∂Ôºâ
          timeout 180s bash -c "
            while true; do
              if kubectl rollout status deployment/frontend-deployment -n ${{ env.NAMESPACE }} --timeout=60s 2>/dev/null; then
                echo '‚úÖ Frontend deployment ready'
                break
              fi
              echo '‚è≥ Frontend still deploying...'
              sleep 10
            done
          " || echo "‚ö†Ô∏è Frontend deployment timeout, continuing..."

      - name: üìä Quick Status Check
        run: |
          echo "üìä Current deployment status:"
          kubectl get pods -n ${{ env.NAMESPACE }} --no-headers | while read line; do
            POD_NAME=$(echo $line | awk '{print $1}')
            STATUS=$(echo $line | awk '{print $3}')
            READY=$(echo $line | awk '{print $2}')
            echo "  $POD_NAME: $STATUS ($READY)"
          done

          echo -e "\nüìã Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}

          echo -e "\nüåê Ingress:"
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: üîç Get ALB Ingress URL (Fast)
        run: |
          echo "üöÄ Retrieving ALB ingress URL..."
          
          # Âø´ÈÄüÊ£ÄÊü•Ôºå‰∏çÁ≠âÂæÖÂ§™‰πÖ
          for i in {1..3}; do
            ALB_URL=$(kubectl get ingress comic-website-ingress -n ${{ env.NAMESPACE }} -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$ALB_URL" ]; then
              echo "‚úÖ ALB is ready!"
              echo "üåê ALB URL: http://$ALB_URL"
              echo "ALB_URL=http://$ALB_URL" >> $GITHUB_ENV
              break
            fi
            echo "‚è≥ ALB not ready yet (attempt $i/3)..."
            sleep 10
          done

          if [ -z "$ALB_URL" ]; then
            echo "‚ÑπÔ∏è ALB not ready yet. It will be available soon."
            echo "You can check later with: kubectl get ingress -n ${{ env.NAMESPACE }}"
          fi

      - name: üß™ Quick Health Check
        if: env.ALB_URL != ''
        run: |
          echo "üß™ Performing quick health check..."
          timeout 30s bash -c "
            until curl -f $ALB_URL/health 2>/dev/null; do
              echo '‚è≥ Health check not ready...'
              sleep 5
            done
          " && echo "‚úÖ Health check passed!" || echo "‚ö†Ô∏è Health check timeout or failed"